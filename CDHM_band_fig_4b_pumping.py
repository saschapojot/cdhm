# -*- coding: utf-8 -*-"""Created on Fri May 18 15:29:42 2018Chern number calcualtion in Lognwen's EPJB@author: e0272499"""import numpy as npimport matplotlib.pyplot as pltfrom numpy import piimport timeitimport copyimport pandas as pdfrom mpl_toolkits import mplot3dp = 1; q = 3;alpha = p/qJ = 2.5                                                    #Hopping termV = 2.5                                                     #Driving termT = 2Omega = 2*pi/T                                              #Driving freqN = 100                                                    #Total number of kickdt = T/N                                                    #Time step t_total = np.linspace(0,T,N)                                #timeN_beta =  1000                                                #Discretization of betaS = 1024                                                     #number of unit cellL = S*qN_bloch = S                                              #Discretization of Bloch phase                                beta_total  = np.linspace(0,2*pi,N_beta)                    #Phase shiftt_total     = np.linspace(0,T,   N     )                   bloch_total = np.linspace(0,2*pi,S)                   #Bloch phaseU1 = np.zeros([q,q],dtype = complex)U2 = np.zeros([q,q],dtype = complex)U3 = np.zeros([q,q],dtype = complex)Eigenphase = np.zeros([N_bloch,N_beta,q])EigenV = np.zeros([q,N_bloch,q],dtype = complex)     #Eigenvector for all band.The fisrt index is the number of bandcopy_EigenV = np.zeros([q,N_bloch,q],dtype = complex)Chern = np.zeros([q,N_bloch,N_beta])                        #Chern number   count = 0def inner_pro(a,b):    return np.dot(np.conj(a),b)#Calculate the eigenvector and t                                                                    he eigenphase#First order split operator for m in range(q):    for n in range(q):        U1[m][n] = np.exp(-1j*2*pi*(m+1)*(n+1)/q)/np.sqrt(q)        U3[m][n] = np.exp( 1j*2*pi*(m+1)*(n+1)/q)/np.sqrt(q)        start_time = timeit.default_timer()#reduced floquet Hfor idx_bloch,bloch in enumerate(bloch_total):    U2 = np.diag(np.exp(1j*bloch*np.arange(1,1+q)/q))@U1@np.diag(np.exp(-1j*J*dt*np.cos((2*pi* np.arange(1,1+q) - bloch )/q )))@U3    beta = 0    U = np.eye(q,dtype=complex)    for t in t_total:        U_temp = U2@np.diag(np.exp(-1j*V*dt*np.cos(2*pi*alpha*np.arange(1,1+q) - beta)*np.cos(Omega*t)  ))@np.diag(np.exp(-1j*bloch*np.arange(1,1+q)/q ))        U = U_temp@U    [eigenvalues_U,eigenvector_U] = np.linalg.eig(U)    eigenphase = np.angle(eigenvalues_U)    sort_idx = np.argsort(eigenphase)    for idx_q,sort_index in enumerate(sort_idx):        Eigenphase[idx_bloch,idx_q] = eigenphase[sort_index]        EigenV[idx_q,idx_bloch,:] = eigenvector_U[:,sort_index]    count += 1    print("finish ",count/(N_bloch)*100," %")    print("The running time is :", timeit.default_timer() - start_time)#choose the middle bandeigv_2 = EigenV[1,:,:]#phase smoothfor idx_bloch in range(S-1):    overlap = inner_pro(eigv_2[idx_bloch,:],eigv_2[idx_bloch+1,:])    phase_diff = np.imag(np.log(overlap/np.abs(overlap)))    eigv_2[idx_bloch+1,:] = np.exp(-1j*phase_diff) * eigv_2[idx_bloch+1,:]overlap = inner_pro(eigv_2[0,:],eigv_2[-1,:])phase_diff = np.imag(np.log(overlap/np.abs(overlap)))for idx_bloch in range(S-1):    eigen_temp = eigv_2[idx_bloch,:]    eigv_2[idx_bloch,:] = np.exp(-1j*idx_bloch*phase_diff/S)*eigen_temp#wannier state located at the center of the chainwannier_temp = np.zeros([q,S],dtype = complex)wannier_state = np.zeros(q*S, dtype = complex)    for idx_q in range(q):    wannier_temp[idx_q,: ] = np.fft.ifft(eigv_2[:,idx_q])    wannier_state[idx_q::q] = wannier_temp[idx_q,:]    wannier_state/=np.linalg.norm(wannier_state,ord=2)initDat=np.array([wannier_state,np.abs(wannier_state)]).Tdf0=pd.DataFrame(initDat,columns=["psi0","abs"])df0.to_csv("ws01.csv")location = np.append(np.arange(1,L/2+q +1), np.arange(1+q-L/2,1))# location=np.arange(0,L)ini_center = np.sum(location* (np.abs(wannier_state)**2))evo_state = copy.copy(wannier_state)# plt.figure()# plt.plot(np.arange(q*S), np.abs(wannier_state), '.r')plt.figure()plt.plot(location, np.abs(wannier_state), 'r')plt.savefig("tmp21.png")#start the time evolutionk_total = np.linspace(0,2*pi,L,endpoint=False)                   #Bloch phase#time evolutionfor idx_beta, beta in enumerate(beta_total):    for idx_t,t in enumerate(t_total):        temp_1 = np.exp(-1j*(V*dt*np.cos(2*pi*alpha*location - beta)*np.cos(Omega*t)  )) *evo_state        temp_2 = np.fft.ifft(temp_1)        temp_3 = np.exp(-1j*J*dt*np.cos(k_total) ) *temp_2        evo_state = np.fft.fft(temp_3)            f_center = np.sum(location* (np.abs(evo_state)**2))dis = (f_center - ini_center)/qprint(dis)plt.figure()plt.plot(location, np.abs(evo_state), 'r')plt.savefig("last1.png")        psi1Dat=np.array(evo_state).Tdf1=pd.DataFrame(psi1Dat,columns=["psi"])df1.to_csv("psiLast1.csv")                                                                